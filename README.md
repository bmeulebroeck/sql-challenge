# sql-challenge

<h2>Evaluating the data and putting together the ERD</h2>
<p>I opened up all the CSVs and used QuickDBD (app.quickdatabasediagrams.com) to put together my entity relationship diagram and to figure out how the tables were related. I set up the primary keys for each table and figured out how to link them together. Through this process I also placed them in the order I wanted to create them so that all the key references would work (titles, employees, salaries, departments, department managers, department employees).</p>
<p>Then in Postgres I started a new query tool and input my table schema. From class questions I knew there was an issue with the dept_employee table since employees are assigned to multiple departments and therefore the emp_no cannot be the primary key since it is not unique. I researched composite keys and found a good explainer on objectrocket.com (https://kb.objectrocket.com/postgresql/postgresql-composite-primary-keys-629). That helped me to set up the composite key that reference both emp_no and dept_no to get a unique value that could act as the key. Created all the tables successfully.</p>
<p>The import went smoothly - I saw the hint about importing in the same order that the tables were created and did not run into any issues.</p>

<h2>Building the queries</h2>
<p>I started a new query and saved it as ph_emp_queries.sql.</p>
1. Employee info plus salary: I completed this query with a straightforward join using the employees and salaries table.
2. Employees hired during 1986: I tried a few methods here. I first just tried a straight forward WHERE statement using > and < against the hire date but couldn't get the syntax quite right. I researched the 'BETWEEN' method and ended up using that to establish the date range.
3. List each department and assigned managers: This one got a little more complicated since I needed to join both departments and employees to the dept_manager table and get all the required info. It took a little trial and error to get the FROM table and INNER join tables in the right order to get the output I wanted.
4. List each employee and their assigned department(s): Similar to #3 - went smooth after I figured out that one.
5. Find employees with first name 'Hercules' and last name starting with 'B': I used the exact match for the first name, and for the last name used 'LIKE 'B%' to get the requested output.
6. List all employees in the sales department: I had the same issue as #3 - getting the joins in the right order. Once I had the tables in the right places I used a WHERE statement to find the match for sales (d007)
7. List all employees in the sales and development departments: I used the same query as #6 but added the development department (d005) as a conditional. I also ordered by department name the first time but the list was so large I was only seeing development. I switched it to order by employee number so I could see the mix of both departments was coming through correctly in the output.
8. Frequency count of last names in descending order: This one tripped me up at first since I was just getting the overall count of last names. I looked back to the class examples (Sql day 2 Act 5) and found an example similar to this one. That made me realize I needed to SELECT both last_name and COUNT(last_name) to get the output I wanted.

<h2>Bonus</h2>
<p>I started with the code from the instructions ReadMe. When I first tried to run my code I was getting errors asking for psycopg2, so I researched and found that it acts as a PostgreSQL database adapter. I installed that and then was having some issues with getting my url all formatted correctly with my user/pw. I set up a config file to store my password (and a .gitignore to keep it from being uploaded), and then used the SQL Alchemy documentation on Engine configuration to get my DB url written correctly. I was then able to excecute and get the connection established.</p>
<p>Next I read in the employees, salaries, and titles tables into dataframes. I did a count on unique employee numbers to establish how many employees I needed to have in my final df after the merges. The first merge I did was employees to salaries on 'emp_no', and then I merged that df to titles. In order to make that work I had to refer to the pandas .merge documentation to get the syntax on joining on columns that are not an exact match (left_on="emp_title_id", right_on="title_id"). After that I had a final df that contained all the info required.</p>
<p>I did a groupby on 'title' and then found the mean on salaries and stored that in avg_sal. I then did a bar graph showing avg salary by title.</p>
<p>The histogram for salary ranges did give me a few headaches. My first attempt I mistakenly tried to plot the entire merged dataframe which locked up my jupyter notebook. For my next attempt I isolated salaries into a list on it's own, then plotted just that column in a histogram.</p>
<p>Finally for the epilogue I used .loc to isolate the info for emp_no 499942. I discovered that my name is "April Foolsday". Thanks boss.</p>
